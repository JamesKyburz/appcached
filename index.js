var once = require('once')
  , crypto = require('crypto')
  , webtouch = require('webtouch')
  , _ = require('lodash')
  , hash = function (body) { return crypto.createHash('md5').update(body).digest('hex') }
  ;

function zipobj (obj) {
  return _.zip(_.keys(opts.network), _.values(obj)).map(function (xy) {return xy.join(' ')})
}

function mkmanifest (opts) {
  var lines = ['CACHE MANIFEST', '# generated by github.com/mikeal/appcached']
  lines.push('# md5 '+opts.md5)
  lines.push('')
  lines.push('CACHE:')
  lines = lines.concat(opts.cache)
  if (opts.network) {
    lines.push('')
    lines.push('NETWORK:')
    lines = lines.concat(opts.network)
  }
  if (opts.fallback) {
    lines.push('')
    lines.push('FALLBACK:')
    lines = lines.concat(zipobj(opts.fallback))
  }
  return lines.join('\r\n')
}

function appcached (resources, opts, cb) {
  var etags = {}
    , expectedLength
    ;
  if (typeof resources === 'string') resources = [resources]
  if (!cb) {
    cb = opts
    opts = {}
  }
  if (!opts.cache) opts.cache = []
  cb = once(cb)
  var touching = webtouch(resources, function (e, urls) {
    if (e) return cb(e)
    if (!opts.md5) opts.md5 = hash(_.values(etags).sort().join(''))
    opts.cache = opts.cache.concat(_.keys(etags))
    cb(null, mkmanifest(opts))
  })
  touching.on('resp', function (resp) {
    // DO NOT EVER CACHE A CACHE MANIFEST
    if (resp.headers['content-type'] && resp.headers['content-type'] === 'text/cache-manifest') return
    if (resp.request.href.slice(resp.request.href.length, '.appcache'.length) === '.appcache') return
    etags[resp.request.href] = hash(resp.body)
  })
}

module.exports = appcached

appcached('http://staging.getable.com/app', function (e, manifest) {
  console.log(manifest)
})
